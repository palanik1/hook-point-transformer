           long bpf_probe_read(void *dst, u32 size, const void *unsafe_ptr)

             Description
                    For tracing programs, safely attempt to read size
                    bytes from kernel space address unsafe_ptr and
                    store the data in dst.

                    Generally, use bpf_probe_read_user() or
                    bpf_probe_read_kernel() instead.

             Return 0 on success, or a negative error in case of
                    failure.
      u32 bpf_get_prandom_u32(void)

             Description
                    Get a pseudo-random number.

                    From a security point of view, this helper uses its
                    own pseudo-random internal state, and cannot be
                    used to infer the seed of other random functions in
                    the kernel. However, it is essential to note that
                    the generator used by the helper is not
                    cryptographically secure.

             Return A random 32-bit unsigned value.

      u32 bpf_get_smp_processor_id(void)

             Description
                    Get the SMP (symmetric multiprocessing) processor
                    id. Note that all programs run with preemption
                    disabled, which means that the SMP processor id is
                    stable during all the execution of the program.

             Return The SMP id of the processor running the program.
      u64 bpf_get_current_pid_tgid(void)

             Return A 64-bit integer containing the current tgid and
                    pid, and created as such: current_task->tgid << 32
                    | current_task->pid.

      u64 bpf_get_current_uid_gid(void)

             Return A 64-bit integer containing the current GID and
                    UID, and created as such: current_gid << 32 |
                    current_uid.
      u32 bpf_get_cgroup_classid(struct sk_buff *skb)

             Description
                    Retrieve the classid for the current task, i.e. for
                    the net_cls cgroup to which skb belongs.

                    This helper can be used on TC egress path, but not
                    on ingress.

                    The net_cls cgroup provides an interface to tag
                    network packets based on a user-provided identifier
                    for all traffic coming from the tasks belonging to
                    the related cgroup. See also the related kernel
                    documentation, available from the Linux sources in
                    file
                    Documentation/admin-guide/cgroup-v1/net_cls.rst.

                    The Linux kernel has two versions for cgroups:
                    there are cgroups v1 and cgroups v2. Both are
                    available to users, who can use a mixture of them,
                    but note that the net_cls cgroup is for cgroup v1
                    only. This makes it incompatible with BPF programs
                    run on cgroups, which is a cgroup-v2-only feature
                    (a socket can only hold data for one version of
                    cgroups at a time).

                    This helper is only available is the kernel was
                    compiled with the CONFIG_CGROUP_NET_CLASSID
                    configuration option set to "y" or to "m".

             Return The classid, or 0 for the default unconfigured
                    classid.
      u64 bpf_perf_event_read(struct bpf_map *map, u64 flags)

             Description
                    Read the value of a perf event counter. This helper
                    relies on a map of type
                    BPF_MAP_TYPE_PERF_EVENT_ARRAY. The nature of the
                    perf event counter is selected when map is updated
                    with perf event file descriptors. The map is an
                    array whose size is the number of available CPUs,
                    and each cell contains a value relative to one CPU.
                    The value to retrieve is indicated by flags, that
                    contains the index of the CPU to look up, masked
                    with BPF_F_INDEX_MASK. Alternatively, flags can be
                    set to BPF_F_CURRENT_CPU to indicate that the value
                    for the current CPU should be retrieved.

                    Note that before Linux 4.13, only hardware perf
                    event can be retrieved.

                    Also, be aware that the newer helper
                    bpf_perf_event_read_value() is recommended over
                    bpf_perf_event_read() in general. The latter has
                    some ABI quirks where error and counter value are
                    used as a return code (which is wrong to do since
                    ranges may overlap). This issue is fixed with
                    bpf_perf_event_read_value(), which at the same time
                    provides more features over the
                    bpf_perf_event_read() interface. Please refer to
                    the description of bpf_perf_event_read_value() for
                    details.

             Return The value of the perf event counter read from the
                    map, or a negative error code in case of failure.

      long bpf_perf_event_output(void *ctx, struct bpf_map *map, u64
      flags, void *data, u64 size)

             Description
                    Write raw data blob into a special BPF perf event
                    held by map of type BPF_MAP_TYPE_PERF_EVENT_ARRAY.
                    This perf event must have the following attributes:
                    PERF_SAMPLE_RAW as sample_type, PERF_TYPE_SOFTWARE
                    as type, and PERF_COUNT_SW_BPF_OUTPUT as config.

                    The flags are used to indicate the index in map for
                    which the value must be put, masked with
                    BPF_F_INDEX_MASK.  Alternatively, flags can be set
                    to BPF_F_CURRENT_CPU to indicate that the index of
                    the current CPU core should be used.

                    The value to write, of size, is passed through eBPF
                    stack and pointed by data.

                    The context of the program ctx needs also be passed
                    to the helper.

                    On user space, a program willing to read the values
                    needs to call perf_event_open() on the perf event
                    (either for one or for all CPUs) and to store the
                    file descriptor into the map. This must be done
                    before the eBPF program can send data into it. An
                    example is available in file
                    samples/bpf/trace_output_user.c in the Linux kernel
                    source tree (the eBPF program counterpart is in
                    samples/bpf/trace_output_kern.c).

                    bpf_perf_event_output() achieves better performance
                    than bpf_trace_printk() for sharing data with user
                    space, and is much better suitable for streaming
                    data from eBPF programs.

                    Note that this helper is not restricted to tracing
                    use cases and can be used with programs attached to
                    TC or XDP as well, where it allows for passing data
                    to user space listeners. Data can be:

                    • Only custom structs,

                    • Only the packet payload, or

                    • A combination of both.

             Return 0 on success, or a negative error in case of
                    failure.
      long bpf_get_stackid(void *ctx, struct bpf_map *map, u64 flags)

             Description
                    Walk a user or a kernel stack and return its id. To
                    achieve this, the helper needs ctx, which is a
                    pointer to the context on which the tracing program
                    is executed, and a pointer to a map of type
                    BPF_MAP_TYPE_STACK_TRACE.

                    The last argument, flags, holds the number of stack
                    frames to skip (from 0 to 255), masked with
                    BPF_F_SKIP_FIELD_MASK. The next bits can be used to
                    set a combination of the following flags:

                    BPF_F_USER_STACK
                           Collect a user space stack instead of a
                           kernel stack.

                    BPF_F_FAST_STACK_CMP
                           Compare stacks by hash only.

                    BPF_F_REUSE_STACKID
                           If two different stacks hash into the same
                           stackid, discard the old one.

                    The stack id retrieved is a 32 bit long integer
                    handle which can be further combined with other
                    data (including other stack ids) and used as a key
                    into maps. This can be useful for generating a
                    variety of graphs (such as flame graphs or off-cpu
                    graphs).

                    For walking a stack, this helper is an improvement
                    over bpf_probe_read(), which can be used with
                    unrolled loops but is not efficient and consumes a
                    lot of eBPF instructions.  Instead,
                    bpf_get_stackid() can collect up to
                    PERF_MAX_STACK_DEPTH both kernel and user frames.
                    Note that this limit can be controlled with the
                    sysctl program, and that it should be manually
                    increased in order to profile long user stacks
                    (such as stacks for Java programs). To do so, use:

                       # sysctl kernel.perf_event_max_stack=<new value>

             Return The positive or null stack id on success, or a
                    negative error in case of failure.

      u64 bpf_get_current_task(void)

             Return A pointer to the current task struct.

      long bpf_probe_write_user(void *dst, const void *src, u32 len)

             Description
                    Attempt in a safe way to write len bytes from the
                    buffer src to dst in memory. It only works for
                    threads that are in user context, and dst must be a
                    valid user space address.

                    This helper should not be used to implement any
                    kind of security mechanism because of TOC-TOU
                    attacks, but rather to debug, divert, and
                    manipulate execution of semi-cooperative processes.

                    Keep in mind that this feature is meant for
                    experiments, and it has a risk of crashing the
                    system and running programs.  Therefore, when an
                    eBPF program using this helper is attached, a
                    warning including PID and process name is printed
                    to kernel logs.

             Return 0 on success, or a negative error in case of
                    failure.

      long bpf_current_task_under_cgroup(struct bpf_map *map, u32
      index)

             Description
                    Check whether the probe is being run is the context
                    of a given subset of the cgroup2 hierarchy. The
                    cgroup2 to test is held by map of type
                    BPF_MAP_TYPE_CGROUP_ARRAY, at index.

             Return The return value depends on the result of the test,
                    and can be:

                    • 0, if the skb task belongs to the cgroup2.

                    • 1, if the skb task does not belong to the
                      cgroup2.

                    • A negative error code, if an error occurred.

      long bpf_get_numa_node_id(void)

             Description
                    Return the id of the current NUMA node. The primary
                    use case for this helper is the selection of
                    sockets for the local NUMA node, when the program
                    is attached to sockets using the
                    SO_ATTACH_REUSEPORT_EBPF option (see also
                    socket(7)), but the helper is also available to
                    other eBPF program types, similarly to
                    bpf_get_smp_processor_id().

             Return The id of current NUMA node.

      long bpf_probe_read_str(void *dst, u32 size, const void
      *unsafe_ptr)

             Description
                    Copy a NUL terminated string from an unsafe kernel
                    address unsafe_ptr to dst. See
                    bpf_probe_read_kernel_str() for more details.

                    Generally, use bpf_probe_read_user_str() or
                    bpf_probe_read_kernel_str() instead.

             Return On success, the strictly positive length of the
                    string, including the trailing NUL character. On
                    error, a negative value.

      long bpf_perf_event_read_value(struct bpf_map *map, u64 flags,
      struct bpf_perf_event_value *buf, u32 buf_size)

             Description
                    Read the value of a perf event counter, and store
                    it into buf of size buf_size. This helper relies on
                    a map of type BPF_MAP_TYPE_PERF_EVENT_ARRAY. The
                    nature of the perf event counter is selected when
                    map is updated with perf event file descriptors.
                    The map is an array whose size is the number of
                    available CPUs, and each cell contains a value
                    relative to one CPU. The value to retrieve is
                    indicated by flags, that contains the index of the
                    CPU to look up, masked with BPF_F_INDEX_MASK.
                    Alternatively, flags can be set to
                    BPF_F_CURRENT_CPU to indicate that the value for
                    the current CPU should be retrieved.

                    This helper behaves in a way close to
                    bpf_perf_event_read() helper, save that instead of
                    just returning the value observed, it fills the buf
                    structure. This allows for additional data to be
                    retrieved: in particular, the enabled and running
                    times (in buf->enabled and buf->running,
                    respectively) are copied. In general,
                    bpf_perf_event_read_value() is recommended over
                    bpf_perf_event_read(), which has some ABI issues
                    and provides fewer functionalities.

                    These values are interesting, because hardware PMU
                    (Performance Monitoring Unit) counters are limited
                    resources. When there are more PMU based perf
                    events opened than available counters, kernel will
                    multiplex these events so each event gets certain
                    percentage (but not all) of the PMU time. In case
                    that multiplexing happens, the number of samples or
                    counter value will not reflect the case compared to
                    when no multiplexing occurs. This makes comparison
                    between different runs difficult.  Typically, the
                    counter value should be normalized before comparing
                    to other experiments. The usual normalization is
                    done as follows.

                       normalized_counter = counter * t_enabled / t_running

                    Where t_enabled is the time enabled for event and
                    t_running is the time running for event since last
                    normalization. The enabled and running times are
                    accumulated since the perf event open. To achieve
                    scaling factor between two invocations of an eBPF
                    program, users can use CPU id as the key (which is
                    typical for perf array usage model) to remember the
                    previous value and do the calculation inside the
                    eBPF program.

             Return 0 on success, or a negative error in case of
                    failure.

      long bpf_perf_prog_read_value(struct bpf_perf_event_data *ctx,
      struct bpf_perf_event_value *buf, u32 buf_size)

             Description
                    For en eBPF program attached to a perf event,
                    retrieve the value of the event counter associated
                    to ctx and store it in the structure pointed by buf
                    and of size buf_size. Enabled and running times are
                    also stored in the structure (see description of
                    helper bpf_perf_event_read_value() for more
                    details).

             Return 0 on success, or a negative error in case of
                    failure.
      long bpf_override_return(struct pt_regs *regs, u64 rc)

             Description
                    Used for error injection, this helper uses kprobes
                    to override the return value of the probed
                    function, and to set it to rc.  The first argument
                    is the context regs on which the kprobe works.

                    This helper works by setting the PC (program
                    counter) to an override function which is run in
                    place of the original probed function. This means
                    the probed function is not run at all. The
                    replacement function just returns with the required
                    value.

                    This helper has security implications, and thus is
                    subject to restrictions. It is only available if
                    the kernel was compiled with the
                    CONFIG_BPF_KPROBE_OVERRIDE configuration option,
                    and in this case it only works on functions tagged
                    with ALLOW_ERROR_INJECTION in the kernel code.

                    Also, the helper is only available for the
                    architectures having the
                    CONFIG_FUNCTION_ERROR_INJECTION option. As of this
                    writing, x86 architecture is the only one to
                    support this feature.

             Return 0
      long bpf_get_stack(void *ctx, void *buf, u32 size, u64 flags)

             Description
                    Return a user or a kernel stack in bpf program
                    provided buffer.  To achieve this, the helper needs
                    ctx, which is a pointer to the context on which the
                    tracing program is executed.  To store the
                    stacktrace, the bpf program provides buf with a
                    nonnegative size.

                    The last argument, flags, holds the number of stack
                    frames to skip (from 0 to 255), masked with
                    BPF_F_SKIP_FIELD_MASK. The next bits can be used to
                    set the following flags:

                    BPF_F_USER_STACK
                           Collect a user space stack instead of a
                           kernel stack.

                    BPF_F_USER_BUILD_ID
                           Collect buildid+offset instead of ips for
                           user stack, only valid if BPF_F_USER_STACK
                           is also specified.

                    bpf_get_stack() can collect up to
                    PERF_MAX_STACK_DEPTH both kernel and user frames,
                    subject to sufficient large buffer size. Note that
                    this limit can be controlled with the sysctl
                    program, and that it should be manually increased
                    in order to profile long user stacks (such as
                    stacks for Java programs). To do so, use:

                       # sysctl kernel.perf_event_max_stack=<new value>

             Return A non-negative value equal to or less than size on
                    success, or a negative error in case of failure.

      long bpf_rc_repeat(void *ctx)

             Description
                    This helper is used in programs implementing IR
                    decoding, to report a successfully decoded repeat
                    key message. This delays the generation of a key up
                    event for previously generated key down event.

                    Some IR protocols like NEC have a special IR
                    message for repeating last button, for when a
                    button is held down.

                    The ctx should point to the lirc sample as passed
                    into the program.

                    This helper is only available is the kernel was
                    compiled with the CONFIG_BPF_LIRC_MODE2
                    configuration option set to "y".

             Return 0

      long bpf_rc_keydown(void *ctx, u32 protocol, u64 scancode, u32
      toggle)

             Description
                    This helper is used in programs implementing IR
                    decoding, to report a successfully decoded key
                    press with scancode, toggle value in the given
                    protocol. The scancode will be translated to a
                    keycode using the rc keymap, and reported as an
                    input key down event. After a period a key up event
                    is generated. This period can be extended by
                    calling either bpf_rc_keydown() again with the same
                    values, or calling bpf_rc_repeat().

                    Some protocols include a toggle bit, in case the
                    button was released and pressed again between
                    consecutive scancodes.

                    The ctx should point to the lirc sample as passed
                    into the program.

                    The protocol is the decoded protocol number (see
                    enum rc_proto for some predefined values).

                    This helper is only available is the kernel was
                    compiled with the CONFIG_BPF_LIRC_MODE2
                    configuration option set to "y".

             Return 0
      u64 bpf_get_current_cgroup_id(void)

             Return A 64-bit integer containing the current cgroup id
                    based on the cgroup within which the current task
                    is running.

      void *bpf_get_local_storage(void *map, u64 flags)

             Description
                    Get the pointer to the local storage area.  The
                    type and the size of the local storage is defined
                    by the map argument.  The flags meaning is specific
                    for each map type, and has to be 0 for cgroup local
                    storage.

                    Depending on the BPF program type, a local storage
                    area can be shared between multiple instances of
                    the BPF program, running simultaneously.

                    A user should care about the synchronization by
                    himself.  For example, by using the BPF_STX_XADD
                    instruction to alter the shared data.

             Return A pointer to the local storage area.

      long bpf_map_push_elem(struct bpf_map *map, const void *value,
      u64 flags)

             Description
                    Push an element value in map. flags is one of:

                    BPF_EXIST
                           If the queue/stack is full, the oldest
                           element is removed to make room for this.

             Return 0 on success, or a negative error in case of
                    failure.

      long bpf_map_pop_elem(struct bpf_map *map, void *value)

             Description
                    Pop an element from map.

             Return 0 on success, or a negative error in case of
                    failure.

      long bpf_map_peek_elem(struct bpf_map *map, void *value)

             Description
                    Get an element from map without removing it.

             Return 0 on success, or a negative error in case of
                    failure.

      long bpf_rc_pointer_rel(void *ctx, s32 rel_x, s32 rel_y)

             Description
                    This helper is used in programs implementing IR
                    decoding, to report a successfully decoded pointer
                    movement.

                    The ctx should point to the lirc sample as passed
                    into the program.

                    This helper is only available is the kernel was
                    compiled with the CONFIG_BPF_LIRC_MODE2
                    configuration option set to "y".

             Return 0

      long bpf_spin_lock(struct bpf_spin_lock *lock)

             Description
                    Acquire a spinlock represented by the pointer lock,
                    which is stored as part of a value of a map. Taking
                    the lock allows to safely update the rest of the
                    fields in that value. The spinlock can (and must)
                    later be released with a call to
                    bpf_spin_unlock(lock).

                    Spinlocks in BPF programs come with a number of
                    restrictions and constraints:

                    • bpf_spin_lock objects are only allowed inside
                      maps of types BPF_MAP_TYPE_HASH and
                      BPF_MAP_TYPE_ARRAY (this list could be extended
                      in the future).

                    • BTF description of the map is mandatory.

                    • The BPF program can take ONE lock at a time,
                      since taking two or more could cause dead locks.

                    • Only one struct bpf_spin_lock is allowed per map
                      element.

                    • When the lock is taken, calls (either BPF to BPF
                      or helpers) are not allowed.

                    • The BPF_LD_ABS and BPF_LD_IND instructions are
                      not allowed inside a spinlock-ed region.

                    • The BPF program MUST call bpf_spin_unlock() to
                      release the lock, on all execution paths, before
                      it returns.

                    • The BPF program can access struct bpf_spin_lock
                      only via the bpf_spin_lock() and
                      bpf_spin_unlock() helpers. Loading or storing
                      data into the struct bpf_spin_lock lock; field of
                      a map is not allowed.

                    • To use the bpf_spin_lock() helper, the BTF
                      description of the map value must be a struct and
                      have struct bpf_spin_lock anyname; field at the
                      top level.  Nested lock inside another struct is
                      not allowed.

                    • The struct bpf_spin_lock lock field in a map
                      value must be aligned on a multiple of 4 bytes in
                      that value.

                    • Syscall with command BPF_MAP_LOOKUP_ELEM does not
                      copy the bpf_spin_lock field to user space.

                    • Syscall with command BPF_MAP_UPDATE_ELEM, or
                      update from a BPF program, do not update the
                      bpf_spin_lock field.

                    • bpf_spin_lock cannot be on the stack or inside a
                      networking packet (it can only be inside of a map
                      values).

                    • bpf_spin_lock is available to root only.

                    • Tracing programs and socket filter programs
                      cannot use bpf_spin_lock() due to insufficient
                      preemption checks (but this may change in the
                      future).

                    • bpf_spin_lock is not allowed in inner maps of
                      map-in-map.

             Return 0

      long bpf_spin_unlock(struct bpf_spin_lock *lock)

             Description
                    Release the lock previously locked by a call to
                    bpf_spin_lock(lock).

             Return 0

      long bpf_sysctl_get_name(struct bpf_sysctl *ctx, char *buf,
      size_t buf_len, u64 flags)

             Description
                    Get name of sysctl in /proc/sys/ and copy it into
                    provided by program buffer buf of size buf_len.

                    The buffer is always NUL terminated, unless it's
                    zero-sized.

                    If flags is zero, full name (e.g.
                    "net/ipv4/tcp_mem") is copied. Use
                    BPF_F_SYSCTL_BASE_NAME flag to copy base name only
                    (e.g. "tcp_mem").

             Return Number of character copied (not including the
                    trailing NUL).

                    -E2BIG if the buffer wasn't big enough (buf will
                    contain truncated name in this case).

      long bpf_sysctl_get_current_value(struct bpf_sysctl *ctx, char
      *buf, size_t buf_len)

             Description
                    Get current value of sysctl as it is presented in
                    /proc/sys (incl. newline, etc), and copy it as a
                    string into provided by program buffer buf of size
                    buf_len.

                    The whole value is copied, no matter what file
                    position user space issued e.g. sys_read at.

                    The buffer is always NUL terminated, unless it's
                    zero-sized.

             Return Number of character copied (not including the
                    trailing NUL).

                    -E2BIG if the buffer wasn't big enough (buf will
                    contain truncated name in this case).

                    -EINVAL if current value was unavailable, e.g.
                    because sysctl is uninitialized and read returns
                    -EIO for it.

      long bpf_sysctl_get_new_value(struct bpf_sysctl *ctx, char *buf,
      size_t buf_len)

             Description
                    Get new value being written by user space to sysctl
                    (before the actual write happens) and copy it as a
                    string into provided by program buffer buf of size
                    buf_len.

                    User space may write new value at file position >
                    0.

                    The buffer is always NUL terminated, unless it's
                    zero-sized.

             Return Number of character copied (not including the
                    trailing NUL).

                    -E2BIG if the buffer wasn't big enough (buf will
                    contain truncated name in this case).

                    -EINVAL if sysctl is being read.

      long bpf_sysctl_set_new_value(struct bpf_sysctl *ctx, const char
      *buf, size_t buf_len)

             Description
                    Override new value being written by user space to
                    sysctl with value provided by program in buffer buf
                    of size buf_len.

                    buf should contain a string in same form as
                    provided by user space on sysctl write.

                    User space may write new value at file position >
                    0. To override the whole sysctl value file position
                    should be set to zero.

             Return 0 on success.

                    -E2BIG if the buf_len is too big.

                    -EINVAL if sysctl is being read.

      long bpf_strtol(const char *buf, size_t buf_len, u64 flags, long
      *res)

             Description
                    Convert the initial part of the string from buffer
                    buf of size buf_len to a long integer according to
                    the given base and save the result in res.

                    The string may begin with an arbitrary amount of
                    white space (as determined by isspace(3)) followed
                    by a single optional '-' sign.

                    Five least significant bits of flags encode base,
                    other bits are currently unused.

                    Base must be either 8, 10, 16, or 0 to detect it
                    automatically similar to user space strtol(3).

             Return Number of characters consumed on success. Must be
                    positive but no more than buf_len.

                    -EINVAL if no valid digits were found or
                    unsupported base was provided.

                    -ERANGE if resulting value was out of range.

      long bpf_strtoul(const char *buf, size_t buf_len, u64 flags,
      unsigned long *res)

             Description
                    Convert the initial part of the string from buffer
                    buf of size buf_len to an unsigned long integer
                    according to the given base and save the result in
                    res.

                    The string may begin with an arbitrary amount of
                    white space (as determined by isspace(3)).

                    Five least significant bits of flags encode base,
                    other bits are currently unused.

                    Base must be either 8, 10, 16, or 0 to detect it
                    automatically similar to user space strtoul(3).

             Return Number of characters consumed on success. Must be
                    positive but no more than buf_len.

                    -EINVAL if no valid digits were found or
                    unsupported base was provided.

                    -ERANGE if resulting value was out of range.

      void *bpf_sk_storage_get(struct bpf_map *map, struct bpf_sock
      *sk, void *value, u64 flags)

             Description
                    Get a bpf-local-storage from a sk.

                    Logically, it could be thought of getting the value
                    from a map with sk as the key.  From this
                    perspective,  the usage is not much different from
                    bpf_map_lookup_elem(map, &sk) except this helper
                    enforces the key must be a full socket and the map
                    must be a BPF_MAP_TYPE_SK_STORAGE also.

                    Underneath, the value is stored locally at sk
                    instead of the map.  The map is used as the
                    bpf-local-storage "type". The bpf-local-storage
                    "type" (i.e. the map) is searched against all
                    bpf-local-storages residing at sk.

                    An optional flags (BPF_SK_STORAGE_GET_F_CREATE) can
                    be used such that a new bpf-local-storage will be
                    created if one does not exist.  value can be used
                    together with BPF_SK_STORAGE_GET_F_CREATE to
                    specify the initial value of a bpf-local-storage.
                    If value is NULL, the new bpf-local-storage will be
                    zero initialized.

             Return A bpf-local-storage pointer is returned on success.

                    NULL if not found or there was an error in adding a
                    new bpf-local-storage.

      long bpf_sk_storage_delete(struct bpf_map *map, struct bpf_sock
      *sk)

             Description
                    Delete a bpf-local-storage from a sk.

             Return 0 on success.

                    -ENOENT if the bpf-local-storage cannot be found.

      long bpf_send_signal(u32 sig)

             Description
                    Send signal sig to the process of the current task.
                    The signal may be delivered to any of this
                    process's threads.

             Return 0 on success or successfully queued.

                    -EBUSY if work queue under nmi is full.

                    -EINVAL if sig is invalid.

                    -EPERM if no permission to send the sig.

                    -EAGAIN if bpf program can try again.
      long bpf_probe_read_user(void *dst, u32 size, const void
      *unsafe_ptr)

             Description
                    Safely attempt to read size bytes from user space
                    address unsafe_ptr and store the data in dst.

             Return 0 on success, or a negative error in case of
                    failure.

      long bpf_probe_read_kernel(void *dst, u32 size, const void
      *unsafe_ptr)

             Description
                    Safely attempt to read size bytes from kernel space
                    address unsafe_ptr and store the data in dst.

             Return 0 on success, or a negative error in case of
                    failure.

      long bpf_probe_read_user_str(void *dst, u32 size, const void
      *unsafe_ptr)

             Description
                    Copy a NUL terminated string from an unsafe user
                    address unsafe_ptr to dst. The size should include
                    the terminating NUL byte. In case the string length
                    is smaller than size, the target is not padded with
                    further NUL bytes. If the string length is larger
                    than size, just size-1 bytes are copied and the
                    last byte is set to NUL.

                    On success, the length of the copied string is
                    returned. This makes this helper useful in tracing
                    programs for reading strings, and more importantly
                    to get its length at runtime. See the following
                    snippet:

                       SEC("kprobe/sys_open")
                       void bpf_sys_open(struct pt_regs *ctx)
                       {
                               char buf[PATHLEN]; // PATHLEN is defined to 256
                               int res = bpf_probe_read_user_str(buf, sizeof(buf),
                                                                 ctx->di);

                               // Consume buf, for example push it to
                               // user space via bpf_perf_event_output(); we
                               // can use res (the string length) as event
                               // size, after checking its boundaries.
                       }

                    In comparison, using bpf_probe_read_user() helper
                    here instead to read the string would require to
                    estimate the length at compile time, and would
                    often result in copying more memory than necessary.

                    Another useful use case is when parsing individual
                    process arguments or individual environment
                    variables navigating current->mm->arg_start and
                    current->mm->env_start: using this helper and the
                    return value, one can quickly iterate at the right
                    offset of the memory area.

             Return On success, the strictly positive length of the
                    string, including the trailing NUL character. On
                    error, a negative value.

      long bpf_probe_read_kernel_str(void *dst, u32 size, const void
      *unsafe_ptr)

             Description
                    Copy a NUL terminated string from an unsafe kernel
                    address unsafe_ptr to dst. Same semantics as with
                    bpf_probe_read_user_str() apply.

             Return On success, the strictly positive length of the
                    string, including the trailing NUL character. On
                    error, a negative value.
      long bpf_send_signal_thread(u32 sig)

             Description
                    Send signal sig to the thread corresponding to the
                    current task.

             Return 0 on success or successfully queued.

                    -EBUSY if work queue under nmi is full.

                    -EINVAL if sig is invalid.

                    -EPERM if no permission to send the sig.

                    -EAGAIN if bpf program can try again.

      u64 bpf_jiffies64(void)

             Description
                    Obtain the 64bit jiffies

             Return The 64 bit jiffies

      long bpf_read_branch_records(struct bpf_perf_event_data *ctx,
      void *buf, u32 size, u64 flags)

             Description
                    For an eBPF program attached to a perf event,
                    retrieve the branch records (struct
                    perf_branch_entry) associated to ctx and store it
                    in the buffer pointed by buf up to size size bytes.

             Return On success, number of bytes written to buf. On
                    error, a negative value.

                    The flags can be set to
                    BPF_F_GET_BRANCH_RECORDS_SIZE to instead return the
                    number of bytes required to store all the branch
                    entries. If this flag is set, buf may be NULL.

                    -EINVAL if arguments invalid or size not a multiple
                    of sizeof(struct perf_branch_entry).

                    -ENOENT if architecture does not support branch
                    records.

      long bpf_get_ns_current_pid_tgid(u64 dev, u64 ino, struct
      bpf_pidns_info *nsdata, u32 size)

             Description
                    Returns 0 on success, values for pid and tgid as
                    seen from the current namespace will be returned in
                    nsdata.

             Return 0 on success, or one of the following in case of
                    failure:

                    -EINVAL if dev and inum supplied don't match dev_t
                    and inode number with nsfs of current task, or if
                    dev conversion to dev_t lost high bits.

                    -ENOENT if pidns does not exists for the current
                    task.
      u64 bpf_get_netns_cookie(void *ctx)

             Description
                    Retrieve the cookie (generated by the kernel) of
                    the network namespace the input ctx is associated
                    with. The network namespace cookie remains stable
                    for its lifetime and provides a global identifier
                    that can be assumed unique. If ctx is NULL, then
                    the helper returns the cookie for the initial
                    network namespace. The cookie itself is very
                    similar to that of bpf_get_socket_cookie() helper,
                    but for network namespaces instead of sockets.

             Return A 8-byte long opaque number.

      u64 bpf_get_current_ancestor_cgroup_id(int ancestor_level)

             Description
                    Return id of cgroup v2 that is ancestor of the
                    cgroup associated with the current task at the
                    ancestor_level. The root cgroup is at
                    ancestor_level zero and each step down the
                    hierarchy increments the level. If ancestor_level
                    == level of cgroup associated with the current
                    task, then return value will be the same as that of
                    bpf_get_current_cgroup_id().

                    The helper is useful to implement policies based on
                    cgroups that are upper in hierarchy than immediate
                    cgroup associated with the current task.

                    The format of returned id and helper limitations
                    are same as in bpf_get_current_cgroup_id().

             Return The id is returned or 0 in case the id could not be
                    retrieved.

      long bpf_sk_assign(struct sk_buff *skb, struct bpf_sock *sk, u64
      flags)

             Description
                    Helper is overloaded depending on BPF program type.
                    This description applies to BPF_PROG_TYPE_SCHED_CLS
                    and BPF_PROG_TYPE_SCHED_ACT programs.

                    Assign the sk to the skb. When combined with
                    appropriate routing configuration to receive the
                    packet towards the socket, will cause skb to be
                    delivered to the specified socket.  Subsequent
                    redirection of skb via  bpf_redirect(),
                    bpf_clone_redirect() or other methods outside of
                    BPF may interfere with successful delivery to the
                    socket.

                    This operation is only valid from TC ingress path.

                    The flags argument must be zero.

             Return 0 on success, or a negative error in case of
                    failure:

                    -EINVAL if specified flags are not supported.

                    -ENOENT if the socket is unavailable for
                    assignment.

                    -ENETUNREACH if the socket is unreachable (wrong
                    netns).

                    -EOPNOTSUPP if the operation is not supported, for
                    example a call from outside of TC ingress.

                    -ESOCKTNOSUPPORT if the socket type is not
                    supported (reuseport).

      long bpf_sk_assign(struct bpf_sk_lookup *ctx, struct bpf_sock
      *sk, u64 flags)

             Description
                    Helper is overloaded depending on BPF program type.
                    This description applies to BPF_PROG_TYPE_SK_LOOKUP
                    programs.

                    Select the sk as a result of a socket lookup.

                    For the operation to succeed passed socket must be
                    compatible with the packet description provided by
                    the ctx object.

                    L4 protocol (IPPROTO_TCP or IPPROTO_UDP) must be an
                    exact match. While IP family (AF_INET or AF_INET6)
                    must be compatible, that is IPv6 sockets that are
                    not v6-only can be selected for IPv4 packets.

                    Only TCP listeners and UDP unconnected sockets can
                    be selected. sk can also be NULL to reset any
                    previous selection.

                    flags argument can combination of following values:

                    • BPF_SK_LOOKUP_F_REPLACE to override the previous
                      socket selection, potentially done by a BPF
                      program that ran before us.

                    • BPF_SK_LOOKUP_F_NO_REUSEPORT to skip
                      load-balancing within reuseport group for the
                      socket being selected.

                    On success ctx->sk will point to the selected
                    socket.

             Return 0 on success, or a negative errno in case of
                    failure.

                    • -EAFNOSUPPORT if socket family (sk->family) is
                      not compatible with packet family (ctx->family).

                    • -EEXIST if socket has been already selected,
                      potentially by another program, and
                      BPF_SK_LOOKUP_F_REPLACE flag was not specified.

                    • -EINVAL if unsupported flags were specified.

                    • -EPROTOTYPE if socket L4 protocol (sk->protocol)
                      doesn't match packet protocol (ctx->protocol).

                    • -ESOCKTNOSUPPORT if socket is not in allowed
                      state (TCP listening or UDP unconnected).

      u64 bpf_ktime_get_boot_ns(void)

             Description
                    Return the time elapsed since system boot, in
                    nanoseconds.  Does include the time the system was
                    suspended.  See: clock_gettime(CLOCK_BOOTTIME)

             Return Current ktime.

      long bpf_seq_printf(struct seq_file *m, const char *fmt, u32
      fmt_size, const void *data, u32 data_len)

             Description
                    bpf_seq_printf() uses seq_file seq_printf() to
                    print out the format string.  The m represents the
                    seq_file. The fmt and fmt_size are for the format
                    string itself. The data and data_len are format
                    string arguments. The data are a u64 array and
                    corresponding format string values are stored in
                    the array. For strings and pointers where pointees
                    are accessed, only the pointer values are stored in
                    the data array.  The data_len is the size of data
                    in bytes.

                    Formats %s, %p{i,I}{4,6} requires to read kernel
                    memory.  Reading kernel memory may fail due to
                    either invalid address or valid address but
                    requiring a major memory fault. If reading kernel
                    memory fails, the string for %s will be an empty
                    string, and the ip address for %p{i,I}{4,6} will be
                    0. Not returning error to bpf program is consistent
                    with what bpf_trace_printk() does for now.

             Return 0 on success, or a negative error in case of
                    failure:

                    -EBUSY if per-CPU memory copy buffer is busy, can
                    try again by returning 1 from bpf program.

                    -EINVAL if arguments are invalid, or if fmt is
                    invalid/unsupported.

                    -E2BIG if fmt contains too many format specifiers.

                    -EOVERFLOW if an overflow happened: The same object
                    will be tried again.

      long bpf_seq_write(struct seq_file *m, const void *data, u32 len)

             Description
                    bpf_seq_write() uses seq_file seq_write() to write
                    the data.  The m represents the seq_file. The data
                    and len represent the data to write in bytes.

             Return 0 on success, or a negative error in case of
                    failure:

                    -EOVERFLOW if an overflow happened: The same object
                    will be tried again.

      u64 bpf_sk_cgroup_id(struct bpf_sock *sk)

             Description
                    Return the cgroup v2 id of the socket sk.

                    sk must be a non-NULL pointer to a full socket,
                    e.g. one returned from bpf_sk_lookup_xxx(),
                    bpf_sk_fullsock(), etc. The format of returned id
                    is same as in bpf_skb_cgroup_id().

                    This helper is available only if the kernel was
                    compiled with the CONFIG_SOCK_CGROUP_DATA
                    configuration option.

             Return The id is returned or 0 in case the id could not be
                    retrieved.

      u64 bpf_sk_ancestor_cgroup_id(struct bpf_sock *sk, int
      ancestor_level)

             Description
                    Return id of cgroup v2 that is ancestor of cgroup
                    associated with the sk at the ancestor_level.  The
                    root cgroup is at ancestor_level zero and each step
                    down the hierarchy increments the level. If
                    ancestor_level == level of cgroup associated with
                    sk, then return value will be same as that of
                    bpf_sk_cgroup_id().

                    The helper is useful to implement policies based on
                    cgroups that are upper in hierarchy than immediate
                    cgroup associated with sk.

                    The format of returned id and helper limitations
                    are same as in bpf_sk_cgroup_id().

             Return The id is returned or 0 in case the id could not be
                    retrieved.

      long bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64
      flags)

             Description
                    Copy size bytes from data into a ring buffer
                    ringbuf.  If BPF_RB_NO_WAKEUP is specified in
                    flags, no notification of new data availability is
                    sent.  If BPF_RB_FORCE_WAKEUP is specified in
                    flags, notification of new data availability is
                    sent unconditionally.

             Return 0 on success, or a negative error in case of
                    failure.

      void *bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags)

             Description
                    Reserve size bytes of payload in a ring buffer
                    ringbuf.

             Return Valid pointer with size bytes of memory available;
                    NULL, otherwise.

      void bpf_ringbuf_submit(void *data, u64 flags)

             Description
                    Submit reserved ring buffer sample, pointed to by
                    data.  If BPF_RB_NO_WAKEUP is specified in flags,
                    no notification of new data availability is sent.
                    If BPF_RB_FORCE_WAKEUP is specified in flags,
                    notification of new data availability is sent
                    unconditionally.

             Return Nothing. Always succeeds.

      void bpf_ringbuf_discard(void *data, u64 flags)

             Description
                    Discard reserved ring buffer sample, pointed to by
                    data.  If BPF_RB_NO_WAKEUP is specified in flags,
                    no notification of new data availability is sent.
                    If BPF_RB_FORCE_WAKEUP is specified in flags,
                    notification of new data availability is sent
                    unconditionally.

             Return Nothing. Always succeeds.

      u64 bpf_ringbuf_query(void *ringbuf, u64 flags)

             Description
                    Query various characteristics of provided ring
                    buffer. What exactly is queries is determined by
                    flags:

                    • BPF_RB_AVAIL_DATA: Amount of data not yet
                      consumed.

                    • BPF_RB_RING_SIZE: The size of ring buffer.

                    • BPF_RB_CONS_POS: Consumer position (can wrap
                      around).

                    • BPF_RB_PROD_POS: Producer(s) position (can wrap
                      around).

                    Data returned is just a momentary snapshot of
                    actual values and could be inaccurate, so this
                    facility should be used to power heuristics and for
                    reporting, not to make 100% correct calculation.

             Return Requested value, or 0, if flags are not recognized.

             Description
                    Return a user or a kernel stack in bpf program
                    provided buffer.  To achieve this, the helper needs
                    task, which is a valid pointer to struct
                    task_struct. To store the stacktrace, the bpf
                    program provides buf with a nonnegative size.

                    The last argument, flags, holds the number of stack
                    frames to skip (from 0 to 255), masked with
                    BPF_F_SKIP_FIELD_MASK. The next bits can be used to
                    set the following flags:

                    BPF_F_USER_STACK
                           Collect a user space stack instead of a
                           kernel stack.

                    BPF_F_USER_BUILD_ID
                           Collect buildid+offset instead of ips for
                           user stack, only valid if BPF_F_USER_STACK
                           is also specified.

                    bpf_get_task_stack() can collect up to
                    PERF_MAX_STACK_DEPTH both kernel and user frames,
                    subject to sufficient large buffer size. Note that
                    this limit can be controlled with the sysctl
                    program, and that it should be manually increased
                    in order to profile long user stacks (such as
                    stacks for Java programs). To do so, use:

                       # sysctl kernel.perf_event_max_stack=<new value>

             Return A non-negative value equal to or less than size on
                    success, or a negative error in case of failure.
